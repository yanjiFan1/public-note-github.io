js
1.浅拷贝深拷贝
2.es6 promise  类型  举几个特性   es7 es8 es9
3.this指向问题  如果是箭头函数内有this，则指向它的外层作用域对象；如果外层也是箭头函数，则指向再外层作用域对象。
4.react性能优化问题
5.冒泡与捕获 点击一个
6.基本类型  String Number Undefined Null Object Boolean
7.节流与防抖
8.react 1.目前版本与自己用的版本号   2.新添的生命周期   3.以及现在用的生命周期    4state props区别    5状态值改变了  经过哪些生命周期
	8.1 react 16.8.3 (February 21, 2019)   目前自己的版本是15.6.1(June 14, 2017)
	8.2 React v16.3 版本新生命周期函数浅析及升级方案---参考：https://juejin.im/post/5ae6cd96f265da0b9c106931  
	8.3 
		react组件生命周期分为三个部分：实例化，存在期，销毁时

		当组件在客户端被实例化，第一次被创建时，以下方法依次被调用：
		实例化：
			1、getDefaultProps 对于每个组件实例来讲，这个方法只会调用一次，该组件类的所有后续应用，getDefaultPops 将不会再被调用，其返回的对象可以用于设置默认的 props(properties的缩写) 值
			2、getInitialState 对于组件的每个实例来说，这个方法的调用有且只有一次，用来初始化每个实例的 state，在这个方法里，可以访问组件的 props。每一个React组件都有自己的 state，其与 props 的区别在于 state只存在组件的内部，props 在所有实例中共享。
			！！！
			getInitialState和getDefaultProps的调用是有区别的,getDefaultProps是对于组件类来说只调用一次,后续该类的应用都不会被调用,而getInitialState是对于每个组件实例来讲都会调用，并且只调用一次.


			3、componentWillMount
			4、render
			5、componentDidMount
		当组件在服务端被实例化，首次被创建时，以下方法依次被调用：
			1、getDefaultProps
			2、getInitialState
			3、componentWillMount
			4、render
		componentDidMount 不会在服务端被渲染的过程中调用。

		
	

9.call apply 
10. 判断是否是数组 typeof instanceof
11.url 输入到渲染页面都经历了什么 参考：https://segmentfault.com/a/1190000006879700
	1 DNS解析
	2 TCP连接 详细讲一下
	3 发送HTTP请求
	4 服务器处理请求并返回HTTP报文
	5 浏览器解析渲染页面
	6 连接结束

12 2.快速排序  1.冒泡排序  3.复杂度  时间复杂度 空间复杂度
	快速排序  参考：https://blog.csdn.net/this_ITBoy/article/details/79377515
			复杂度： 参考： https://blog.csdn.net/weshjiness/article/details/8660583 参考：https://blog.csdn.net/zolalad/article/details/11848739
	1. 冒泡排序  最基础的  冒泡排序原理：每一次对比相邻两个数据的大小，小的排在前面，如果前面的数据比后面的大就交换这两个数的位置
       要实现上述规则需要用到两层for循环，外层从第一个数到倒数第二个数，内层从外层的后面一个数到最后一个数
      特点：排序算法的基础。简单实用易于理解，缺点是比较次数多，效率较低。
	var times=0;
	var sort=function(arr){
		for(var i=0;i<arr.length-1;i++){
			for(var j=i+1;j<arr.length;j++){
				if(arr[i]>arr[j]){//如果前面的数据比后面的大就交换
					var temp=arr[i];
					arr[i]=arr[j];
					arr[j]=temp;
				}
			console.log("第"+(++times)+"次排序后："+arr);
			}
		} 
		return arr;
	}
	
	2.快速排序(二分排序) 最常用的 快速排序原理：先找到一个基准点（一般指数组的中部），然后数组被该基准点分为两部分，依次与该基准点数据比较，如果比它小，放左边；反之，放右边。然后左右分别用一个空数组去存储比较后的数据。最后递归执行上述操作，直到数组长度<=1;
	特点：快速，常用。缺点是需要另外声明两个数组，浪费了内存空间资源。
	
	3.
	   时间复杂度：一个算法执行所耗费的时间  空间复杂度：该算法所耗费的存储空间  
		快速排序复杂度：  时间复杂度---最优：O(nlogn) 最差： O(n2)---(n-1 + n -2 +....+1=n*n）O(nlogn)
						 空间复杂度---最优： log2n 最差：O(n) 平均复杂度： O(logn)
         综上：不稳定的排序方法
        冒泡排序复杂度：  时间复杂度---最优 O(n*n)  稳定


13 堆栈问题
14 websocket
15点击事件   onClick addEventListener 区别
16. 数组操作方法 参考：https://juejin.im/post/5b0903b26fb9a07a9d70c7e0
	ES6： 
	   1.Array.of() 返回由所有参数值组成的数组 eg let a = Array.of(3, 11, 8); // [3,11,8]
	   2.Arrary.from() 将两类对象转为真正的数组 
	   	eg：let arr2 = Array.from({0: 'a', 1: 'b', 2:'c', length: 3}) // ["a", "b", "c"] 
	   		let arr = Array.from('hello'); // ['h','e','l','l','o']
    		let arr = Array.from(new Set(['a','b'])); // ['a','b']	
	
	三类：1.改变原数组的值  2.不会改变原数组  3数组的遍历方法
	   1.改变原数组的方法(9个)
		   let arr = [0,1,2]
		   es5:	
		   		1.arr.splice()   //添加/删除数组元素
					index：必需。整数，规定添加/删除项目的位置，使用负数可从数组结尾处规定位置。
					howmany：可选。要删除的项目数量。如果设置为 0，则不会删除项目。
					item1, ..., itemX： 可选。向数组添加的新项目。
				   eg：
				   		let b = [1, 2, 3, 4, 5, 6, 7];
	    				let item = b.splice(-2,3,'添加1','添加2'); // [6,7]  item是删除的元素  b是目前剩下的元素
	    				console.log(b); // [1,2,3,4,5,'添加1','添加2']
	    				// 从数组最后第二个元素开始，删除3个元素，并添加两个元素'添加1'、'添加2'


		   		2.arr.sort() 	 //数组排序  参考：https://juejin.im/entry/59f7f3346fb9a04514635552
				    字符串排列 看起来很正常
				    var a = ["Banana", "Orange", "Apple", "Mango"];
				    a.sort(); // ["Apple","Banana","Mango","Orange"]
				    // 数字排序的时候 因为转换成Unicode字符串之后，有些数字会比较大会排在后面 这显然不是我们想要的
				    var	a = [10, 1, 3, 20,25,8];
				    console.log(a.sort()) // [1,10,20,25,3,8];
				    升序：
					a.sort(function(a,b){
					   return a-b;
					});

		   		3.arr.pop()      //删除一个数组中的最后的一个元素
		   			arr.pop();
		   			console.log(arr); // [1,2] 
		   		4.arr.shift()    //删除数组的第一个元素
		   			arr.shift();
		   			console.log(arr);  //[2,3]
		   		5.arr.push()     //向数组的末尾添加元素
		   		    arr.unshift('末尾');
		   		    console.log(arr);  //[0,1,2,'末尾']
		   		6.arr.unshift()  //可向数组的开头添加一个或更多元素，并返回新的长度。
		   		 eg:
		   		 	arr.unshift('头部');
		   		 	console.log(arr);  //['头部',0,1,2] 
		   		7.arr.reverse()  //颠倒数组中元素的顺序
		         eg:
		         	arr.reverse();  
		         	console.log(arr); //[2,1,0]


		   es6: 8. arr.copyWithin()    参考：https://blog.csdn.net/qq_30100043/article/details/53219365
		   			target （必需）：从该位置开始替换数据。  
		   			start （可选）：从该位置开始读取数据，默认为 0 。如果为负值，表示倒数。   
		   			end （可选）：到该位置前停止读取数据，默认等于数组长度。如果为负值，表示倒数。
		   			eg:
		   			1  //  将 2 号位复制到 1 号位
					[1,2,3,4,5,6].copyWithin(1,2,3)
					// [1, 3, 3, 4, 5, 6]
					2 // -2 相当于 4 号位， -1 相当于 5 号位
					[1, 2, 3, 4, 5,6].copyWithin(0, -2, -1)
					// [5, 2, 3, 4, 5, 6]

		   	    9. arr.fill  fill方法使用给定值，填充一个数组。  参考：http://es6.ruanyifeng.com/#docs/array#%E6%95%B0%E7%BB%84%E5%AE%9E%E4%BE%8B%E7%9A%84-fill
				eg:
				['a', 'b', 'c'].fill(7) // [7, 7, 7]
				new Array(3).fill(7) // [7, 7, 7]
	   2.不会改变原数组(8个)
	   		1.slice   浅拷贝数组的元素
	   			eg:
	   		2.join
	   		3.toLocateString
	   		4.cancat
	   		5.indexOf
	   		6.lastIndexOf
	   		7.includes(es6)


17 原型链 protoType __proto__
18. a b  不存在第三个变量  如何交换a和b？  答案：a = a + b - a,  b = a + b - b;; 这个是个思路，但是有漏洞；   eg： 0.1 + 0.2 -0.1 ！== 0.2 答案是0.2000000000000004(浮点数存在精确度问题)
19. 0.1 + 0.2 === 0.3 ？？？？  答案是不相等
20. 去重问题；   new Set 参考problem1（！！！new Set 和全部去重着重看一下，可能用到）
21 闭包

22.  es5--indexof 和 es6--includes  
indexof 
	1.不够语义化（它的含义是找到参数值的第一个出现位置，所以要去比较是否不等于-1，表达起来不够直观） 
	2.二是，它内部使用严格相等运算符（===）进行判断，这会导致对NaN的误判。
	if (arr.indexOf(el) !== -1) {
	  // ...
	}
includes
	[1, 2, 3].includes(2)     // true

CSS
1.BFC  块引用上下文 按一定规则排序
2.flex布局
3.动画	
4.画三角形；	

1.dom bom分别是什么


react
1.一个组件就是一个状态机，对于特定地输入，它总返回一致的输出。 一个React组件的生命周期分为三个部分：实例化、存在期和销毁时。