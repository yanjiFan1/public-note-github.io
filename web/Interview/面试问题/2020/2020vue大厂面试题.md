1. MVVM

2. .请说一下响应式数据的原理

3. Vue中是如何检测数组变化

4. 为何vue采用异步渲染

5. nextTick实现原理

6. Vue中Computed的特点

7. Watch中的deep:true 是如何实现的 

8. Vue组件的生命周期

要掌握每个生命周期什么时候被调用 
beforeCreate 在实例初始化之后，数据观测(data observer) 之前被调用。 

created 实例已经创建完成之后被调用。在这一步，实例已完成以下的配置：数据观测(data observer)，属性和方法的运算， watch/event 事件回调。这里没有$el 

beforeMount 在挂载开始之前被调用：相关的 render 函数首次被调用。 

mounted el 被新创建的 vm.$el 替换，并挂载到实例上去之后调用该钩子。 

beforeUpdate 数据更新时调用，发生在虚拟 DOM 重新渲染和打补丁之前。 

updated 由于数据更改导致的虚拟 DOM 重新渲染和打补丁，在这之后会调用该钩子。 

beforeDestroy 实例销毁之前调用。在这一步，实例仍然完全可用。 

destroyed Vue 实例销毁后调用。调用后， Vue 实例指示的所有东西都会解绑定，所有的事件 监听器会被移除，所有的子实例也会被销毁。 该钩子在服务器端渲染期间不被调用。 


要掌握每个生命周期内部可以做什么事 
created 实例已经创建完成，因为它是早触发的原因可以进行一些数据，资源的请求。 

mounted 实例已经挂载完成，可以进行一些DOM操作 

beforeUpdate 可以在这个钩子中进一步地更改状态，这不会触发附加的重渲染过程。 

updated 可以执行依赖于 DOM 的操作。然而在大多数情况下，你应该避免在此期间更改状态， 因为这可能会导致更新无限循环。 该钩子在服务器端渲染期间不被调用。 

destroyed 可以执行一些优化操作,清空定时器，解除绑定事件

9. ajax请求放在哪个生命周期中？ 
		created()
服务端渲染不支持mounted方法，所以在服务端渲染的情况下统一放到created中 

10. 何时需要使用beforeDestroy 
	vue实例被销毁  
	1. 可能在当前页面中使用了 $on 方法，那需要在组件销毁前解绑。
	2. 清除自己定义的定时器 
	3. 解除事件的绑定 scroll mousemove .... 

11. vue中模版编译原理
	将 template 转化成 render 函数

12. v-if v-show
v-if是通过控制dom节点的存在与否来控制元素的显隐；v-show是通过设置DOM元素的display样式，block为显示，none为隐藏

v-if 如果条件不成立不会渲染当前指令所在节点的 dom 元素 
v-show 只是切换当前 dom 的显示或者隐藏 


区别
1.手段：v-if是通过控制dom节点的存在与否来控制元素的显隐；v-show是通过设置DOM元素的display样式，block为显示，none为隐藏；
2.编译过程：v-if切换有一个局部编译/卸载的过程，切换过程中合适地销毁和重建内部的事件监听和子组件；v-show只是简单的基于css切换；
3.编译条件：v-if是惰性的，如果初始条件为假，则什么也不做；只有在条件第一次变为真时才开始局部编译（编译被缓存？编译被缓存后，然后再切换的时候进行局部卸载); v-show是在任何条件下（首次条件是否为真）都被编译，然后被缓存，而且DOM元素保留；
4.性能消耗：v-if有更高的切换消耗；v-show有更高的初始渲染消耗；
使用场景
基于以上区别，因此，如果需要非常频繁地切换，则使用 v-show 较好；如果在运行时条件很少改变，则使用 v-if 较好。

总结
v-if判断是否加载，可以减轻服务器的压力，在需要时加载,但有更高的切换开销;v-show调整DOM元素的CSS的dispaly属性，可以使客户端操作更加流畅，但有更高的初始渲染开销。如果需要非常频繁地切换，则使用 v-show 较好；如果在运行时条件很少改变，则使用 v-if 较好。

13. 为什么V-for和v-if不能连用 
v-for 会比 v-if 的优先级高一些,如果连用的话会把 v-if 给每个元素都添加一下,会造成性能问题 

如何解决呢？

computed: {
	activeUsers: function () {
	return this.users.filter(function (user) {
	  return user.isActive
	})
}
}
<ul>
<li
  v-for="user in activeUsers"
  :key="user.id"
>
{{ user.name }}
</li>
</ul>

14. 用vnode来描述一个DOM结构

虚拟节点就是用一个对象来描述真实的 dom 元素

function $createElement(tag,data,...children) {
	let key = data.key;
	delete data.key;
	children = children.map(child => {
		if (typeof child === 'object') {
			return child
		} else {
			return vnode(undefined, undefined, undefined, undefined, child)
		}
	})
	return vnode(tag, props, key, children);
}
export function vnode(tag, data, key, children, text) {
	return {
		tag, // 表示的是当前的标签名
		data, // 表示的是当前的标签上的属性
		key, // 唯一标识用户可能传递
		children,
		text
	}
}

15. diff算法的时间复杂度
两个树的完全的 diff 算法是一个时间复杂度为 O(n3) , Vue 进行了优化·O(n3) 复杂度的问题转换成 O(n) 复杂度的问题(只比较同级不考虑跨级问题)  在前端当中， 你很少会跨越层级地移动Dom元素。 所 以 Virtual Dom只会对同一个层级的元素进行对比



16. vue中的diff算法
1. 先比较同级，再比较子节点
2. 先判断一方有子集另一方没有子集的情况
3. 比较都有子集的情况
4. 递归比较子节点



17. v-for中为什么用key

1. 在写v-for的时候，都需要给元素加上一个key属性

2. key的主要作用就是用来提高渲染性能的！

3.key属性可以避免数据混乱的情况出现 （如果元素中包含了有临时数据的元素，如果不用key就会产生数据混乱）

使用v-for更新已渲染的元素列表时,默认用就地复用策略;列表数据修改的时候,他会根据key值去判断某个值是否修改,如果修改,则重新渲染这一项,否则复用之前的元素;
我们在使用的使用经常会使用index(即数组的下标)来作为key,但其实这是不推荐的一种使用方法;

18. 描述组件渲染和更新过程

