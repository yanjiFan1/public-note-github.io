css部分:
	1.css选择器的优先级
	2.flex布局 流式布局
	3.重绘和回流

js部分：
	1.手写函数防抖和节流 参考:  https://segmentfault.com/a/1190000008768202
	
	函数防抖---->( debounce )： 当调用动作过n毫秒后，才会执行该动作，若在这n毫秒内又调用此动作则将重新计算执
		function debounce(fn,wait) {
			let timer = null;
			return function() {
				clearTimeout(timer);
				timer = setTimeout(() => {
					fn()
				},wait)
			}
		}

		function log() {
			console.log(1)
		}

		window.onsroll = debounce(log,500)


	函数节流( throttle ) 预先设定一个执行周期，当调用动作的时刻大于等于执行周期则执行该动作，然后进入下一个新周期

		function throttle(fn,wait,time) {
			let previous = null; //记录上一次运行的时间
			let timer = null;

			return function() {
				let now = +new Date();

				if(!previous) previous = now; //当上一次执行的时间与当前的时间差大于设置的执行间隔时长的话，就主动执行一次
				if(now - previous > time) {
					clearTimeout(timer);
					fn();
					previous = now; //执行函数后，马上记录当前时间
				} else {
					clearTimeout(timer);
					timer = setTimeout(function() {
						fn();	
					},wait);
				}
			}
		}

		function log() {
			console.log(123)
		}

		window.onscroll = throttle(log,500,2000)


	使用场景：
		window对象的resize、scroll事件
		拖拽时的mousemove事件
		文字输入、自动完成的keyup事件

	2.闭包机制


web部分:
	1.BOM 浏览器运行机制  参考：https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/
 	2.从地址栏中输入url到页面展示都经历了什么
 	3.require.js CommonJs ES6的对比 https://blog.csdn.net/crystal6918/article/details/74906757
 	4.函数式编程
 		好处：
 			1.语义更加清晰
 			2.可复用性更高
 			3.可维护性更好
 			4.作用域局限，副作用少	

 react部分：
 	1.react单向数据流 参考：https://www.jianshu.com/p/810464f1a576
	 	state 驱动应用的数据源
	 	view 以声明方式将state映射到视图
	 	actions 响应在view上的用户输入导致的状态变化
	 简单的单向数据流是指用户访问view，view发出用户交互的Action，在Action里对state进行相应更新。state更新后会触发view更新页面的过程。这样数据总是清晰的单向进行流动，便于维护并且可以预测
	

	2. vuex和 redux解决什么问题

	虽然vue和react 框架本身有自己状态管理，当我们的应用遇到多个组件共享状态时，单向数据流的简洁性很容易被破坏:
		1.多个视图依赖于同一状态
		2.来自不同视图的行为需要变更同一状态

	3.connect 实现原理  参考：https://www.jianshu.com/p/9873d4ccb891
	作用 连接react组件与redux store
	connect([mapStateToProps],[mapDispatchToProps],[mergeProps],[options])
	来分析一下：
		@1 mapStateToProps(state,ownProps) : stateProps    ----> 这个函数允许我们将store中的数据作为props绑定到组件上
		const mapStateToProps = (state) => {
			return {
				count: state.count
			}
		}
		其中state是redux中的store，ownProps是组件中的props
		！！！
		当state变化，或者ownProps变化的时候，mapStateToProps都会被调用，计算出一个新的stateProps，(在与ownProps merge后)更新给组件。
	


		@2 mapDispatchToProps(dispatch,ownProps):dispatchProps -----> 将action作为props绑定到组件上，也会成为MyComp的props
		@3 mergeProps 不管是stateProps还是dispatchProps, 都需要和ownProps merge 之后才会被赋给组件.connect的第三个参数就是用来做这件事。
		通常情况下,你可以不传这个参数，connect就会使用Object.assign替代该方法

		@4. 如果指定这个参数， 可以定制connector的行为，一般不用

	原理解析：：
		首先connect之所以会成功，是因为Provider组件：
		  1.在原应用组件上包裹一层，使原来整个应用成为Provider对的子组件
		  2.接受Redux的store作为props，通过context对象传递给子孙组件上的connect
	
	connect做了什么呢?
		它真正连接Redux和React，它包在我们的容器组件的外一层，它接受上面Provider提供的store里面的state和dispatch,传给一个构造函数，返回一个对象，以属性形式传给我们的容器组件。

	关于它的源码
		connect是一个高阶函数


	export default function connect(mapStateToProps,mapDispatchToProps,mergeProps,options={}) {
		return function wrapWithConnect(WrappedComponent) {
			class Connect extends Component {
				render() {
					return <WrappedComponent {...this.nextState}>
				}
			}
		}
	}
	
	拓展：Provider组件------>React-Redux 提供Provider组件，可以让容器组件拿到state   参考：https://www.jianshu.com/p/81e9e9eaf8fa
	Provider在根组件外面包了一层，这样一来，App的所有子组件就默认都可以拿到state了；-----它的原理是React组件的context属性

	源码：：：
		 class Provider extends Component {
		 	getChildContext() {
		 		return {
		 			store:this.props.store
		 		};
		 	}

		 	render() {
		 		return this.props.children
		 	}
		 }

		 Provider.childContextTypes = {
		 	store: React.PropTypes.object
		 }


	4.react工作原理 双向绑定原理

		


	5.react-router实现原理
	6.react单向数据流
	7.react性能优化   从虚拟dom 和 setState机制讲(setState是同步的)
	8.state更新后会执行哪些生命周期
	9.react生命周期 常用哪些
	10.redux 数据流   view层如何监听   通过订阅事件去监听  例似 vue中的 watcher事件
	11.redux-saga  中间键 解决什么问题； 原理
	12. react的组件放在不同项目中你是如何处理的------->  放在npm私有库中 然后调用
	13.看看优秀的代码 Facebook的instagram.com整站都采用了React来开发，整个页面就是一个大的组件，其中包含了嵌套的大量其它组件，大家有兴趣可以看下它背后的代码

	14 react优缺点： 参考：https://blog.csdn.net/a1943206465/article/details/60570567 拉到最后可以看